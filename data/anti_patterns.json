[
  {
    "name": "SRP Violation",
    "description": "The Single Responsibility Principle (SRP) is one of the SOLID principles of object-oriented design, stating that a class (or, at a lower level, a method) should have only one reason to change (i.e., it should have only one responsibility or concern). A SRP Violation occurs when a class (method) takes on multiple unrelated responsibilities, making it harder to maintain, test, and understand. These violations often result in bloated classes or methods that mix unrelated concerns such as I/O, business logic, error handling, and configuration.",
    "category": "OOP",
    "language": "Java",
    "severity": "Medium",
	"problem": "Poor maintainability: Changing one responsibility might inadvertently affect others, introducing bugs.\nLow cohesion: Code with unrelated responsibilities lacks a clear purpose, reducing clarity and reusability.\nDifficult testing: Unit testing becomes more complex as setup may require mocking or initializing unrelated dependencies.\nCode duplication and tight coupling: Responsibilities are harder to reuse or share, often leading to repeated logic or tight inter-class dependencies.\nHarder onboarding: New developers struggle to understand the purpose and scope of large, multi-purpose classes.",
	"remediation": "Extract Method - Split complex methods into smaller, single-purpose private methods.\nEarly Return (Guard Clauses) - Use early exits to reduce nested logic and clarify separate responsibilities.\nUse Local Functions/Lambdas - Encapsulate small inline logic into local functions for clarity.\nEncapsulate Temporary Variables - Move logic-heavy expressions into descriptive helper methods.\nGroup Related Logic - Cluster related operations into distinct helper methods within the same class.\nSeparate Concerns in Loops - Extract filtering, transforming, and aggregating into distinct steps.\nIsolate Logging/Error Handling - Move side-effect code like logging into dedicated private methods (unless the logging is a trivial single line and does not obscure business logic).",
	"limitation": "Fixing certain SRP violations (especially class-level violations) requires changing public method signatures, creating new classes, and/or breaking interfaces.\nMethods often depend on multiple injected services or shared state; untangling responsibilities might require broader architectural changes.\nLogging, error handling, metrics, and security checks are often scattered across responsibilities and difficult to isolate cleanly at the method level without aspect-oriented programming (AOP) or middleware/interceptor patterns.",
    "examples": [
		{
			"code": "public void checkPath(Path path) {\n    URI uri = path.toUri();\n    String thatScheme = uri.getScheme();\n    String thatAuthority = uri.getAuthority();\n    if (thatScheme == null) {\n      if (thatAuthority == null) {\n        if (path.isUriPathAbsolute()) {\n          return;\n        }\n        throw new InvalidPathException(\"relative paths not allowed:\" + \n            path);\n      } else {\n        throw new InvalidPathException(\n            \"Path without scheme with non-null authority:\" + path);\n      }\n    }\n    String thisScheme = this.getUri().getScheme();\n    String thisHost = this.getUri().getHost();\n    String thatHost = uri.getHost();\n\n    // Schemes and hosts must match.\n    // Allow for null Authority for file:///\n    if (!thisScheme.equalsIgnoreCase(thatScheme) ||\n       (thisHost != null && \n            !thisHost.equalsIgnoreCase(thatHost)) ||\n       (thisHost == null && thatHost != null)) {\n      throw new InvalidPathException(\"Wrong FS: \" + path + \", expected: \"\n          + this.getUri());\n    }\n\n    // Ports must match, unless this FS instance is using the default port, in\n    // which case the port may be omitted from the given URI\n    int thisPort = this.getUri().getPort();\n    int thatPort = uri.getPort();\n    if (thatPort == -1) { // -1 => defaultPort of Uri scheme\n      thatPort = this.getUriDefaultPort();\n    }\n    if (thisPort != thatPort) {\n      throw new InvalidPathException(\"Wrong FS: \" + path\n          + \" and port=\" + thatPort\n          + \", expected: \"\n          + this.getUri()\n          + \" with port=\" + thisPort);\n    }\n  }",
			"reason": "URI validation, statistics tracking, path logic, and instantiation are mixed"
		},
		{
			"code": "@Override\n  public int run(String[] args) throws Exception {\n    try {\n      jc.parse(args);\n    } catch (MissingCommandException e) {\n      console.error(e.getMessage());\n      return 1;\n    } catch (ParameterException e) {\n      help.setProgramName(programName);\n      String cmd = jc.getParsedCommand();\n      if (args.length == 1) {\n        help.helpCommands.add(cmd);\n        help.run();\n        return 1;\n      } else {\n        for (String arg : args) {\n          if (HELP_ARGS.contains(arg)) {\n            help.helpCommands.add(cmd);\n            help.run();\n            return 0;\n          }\n        }\n      }\n      console.error(e.getMessage());\n      return 1;\n    }\n\n    help.setProgramName(programName);\n\n    // configure log4j\n    if (debug) {\n      org.apache.log4j.Logger console = org.apache.log4j.Logger.getLogger(Main.class);\n      console.setLevel(Level.DEBUG);\n    }\n\n    String parsed = jc.getParsedCommand();\n    if (parsed == null) {\n      help.run();\n      return 1;\n    } else if (\"help\".equals(parsed)) {\n      return help.run();\n    }\n\n    Command command = (Command) jc.getCommands().get(parsed).getObjects().get(0);\n    if (command == null) {\n      help.run();\n      return 1;\n    }\n\n    try {\n      if (command instanceof Configurable) {\n        ((Configurable) command).setConf(getConf());\n      }\n      return command.run();\n    } catch (IllegalArgumentException e) {\n      if (debug) {\n        console.error(\"Argument error\", e);\n      } else {\n        console.error(\"Argument error: {}\", e.getMessage());\n      }\n      return 1;\n    } catch (IllegalStateException e) {\n      if (debug) {\n        console.error(\"State error\", e);\n      } else {\n        console.error(\"State error: {}\", e.getMessage());\n      }\n      return 1;\n    } catch (Exception e) {\n      console.error(\"Unknown error\", e);\n      return 1;\n    }\n  }\n\n  public static void main(String[] args) throws Exception {\n    // reconfigure logging with the kite CLI configuration\n    PropertyConfigurator.configure(Main.class.getResource(\"/cli-logging.properties\"));\n    Logger console = LoggerFactory.getLogger(Main.class);\n    // use Log4j for any libraries using commons-logging\n    LogFactory.getFactory()\n      .setAttribute(\"org.apache.commons.logging.Log\", \"org.apache.commons.logging.impl.Log4JLogger\");\n    int rc = ToolRunner.run(new Configuration(), new Main(console), args);\n    System.exit(rc);\n  }",
			"reason": "Command parsing, option merging, command dispatching, help formatting, error handling, logging suppression, and program termination are all mixed in the Main class, violating SRP"
		},
		{
			"code": "@SuppressWarnings(\"checkstyle:methodlength\")\nprivate MavenExecutionResult doExecute(MavenExecutionRequest request) {\n  request.setStartInstant(MonotonicClock.now());\n\n  MavenExecutionResult result = new DefaultMavenExecutionResult();\n\n  try {\n    validateLocalRepository(request);\n  } catch (IOException e) {\n    return addExceptionToResult(result, e);\n  }\n\n  //\n  // We enter the session scope right after the MavenSession creation and before any of the\n  // AbstractLifecycleParticipant lookups\n  // so that @SessionScoped components can be @Injected into AbstractLifecycleParticipants.\n  //\n  sessionScope.enter();\n  MavenChainedWorkspaceReader chainedWorkspaceReader =\n      new MavenChainedWorkspaceReader(request.getWorkspaceReader(), ideWorkspaceReader);\n  try (CloseableSession closeableSession = newCloseableSession(request, chainedWorkspaceReader)) {\n    MavenSession session = new MavenSession(closeableSession, request, result);\n    session.setSession(defaultSessionFactory.newSession(session));\n\n    sessionScope.seed(MavenSession.class, session);\n    sessionScope.seed(Session.class, session.getSession());\n    sessionScope.seed(InternalMavenSession.class, InternalMavenSession.from(session.getSession()));\n\n    legacySupport.setSession(session);\n\n    return doExecute(request, session, result, chainedWorkspaceReader);\n  } finally {\n    sessionScope.exit();\n  }\n}\n\nprivate MavenExecutionResult doExecute(\n    MavenExecutionRequest request,\n    MavenSession session,\n    MavenExecutionResult result,\n    MavenChainedWorkspaceReader chainedWorkspaceReader) {\n  try {\n    afterSessionStart(session);\n  } catch (MavenExecutionException e) {\n    return addExceptionToResult(result, e);\n  }\n\n  try {\n    chainedWorkspaceReader.addReader(lookup.lookup(WorkspaceReader.class, ReactorReader.HINT));\n  } catch (LookupException e) {\n    return addExceptionToResult(result, e);\n  }\n\n  eventCatapult.fire(ExecutionEvent.Type.ProjectDiscoveryStarted, session, null);\n\n  Result<? extends ProjectDependencyGraph> graphResult = buildGraph(session);\n\n  if (graphResult.hasErrors()) {\n    return addExceptionToResult(\n        result, graphResult.getProblems().iterator().next().getException());\n  }\n\n  try {\n    session.setProjectMap(getProjectMap(session.getProjects()));\n  } catch (DuplicateProjectException e) {\n    return addExceptionToResult(result, e);\n  }\n\n  try {\n    setupWorkspaceReader(session, chainedWorkspaceReader);\n  } catch (LookupException e) {\n    return addExceptionToResult(result, e);\n  }\n  try {\n    afterProjectsRead(session);\n  } catch (MavenExecutionException e) {\n    return addExceptionToResult(result, e);\n  }\n\n  //\n  // The projects need to be topologically after the participants have run their afterProjectsRead(session)\n  // because the participant is free to change the dependencies of a project which can potentially change the\n  // topological order of the projects, and therefore can potentially change the build order.\n  //\n  // Note that participants may affect the topological order of the projects, but it is\n  // not expected that a participant will add or remove projects from the session.\n\n  graphResult = buildGraph(session);\n\n  if (graphResult.hasErrors()) {\n    return addExceptionToResult(\n        result, graphResult.getProblems().iterator().next().getException());\n  }\n\n  try {\n    if (result.hasExceptions()) {\n      return result;\n    }\n\n    result.setTopologicallySortedProjects(session.getProjects());\n\n    result.setProject(session.getTopLevelProject());\n\n    validatePrerequisitesForNonMavenPluginProjects(session.getProjects());\n\n    validateRequiredProfiles(session, request.getProfileActivation());\n    if (session.getResult().hasExceptions()) {\n      return result;\n    }\n\n    validateOptionalProfiles(session, request.getProfileActivation());\n\n    LifecycleStarter lifecycleStarter = lookup.lookupOptional(LifecycleStarter.class, request.getBuilderId())\n        .orElseGet(() -> lookup.lookup(LifecycleStarter.class));\n\n    lifecycleStarter.execute(session);\n\n    validateOptionalProjects(request, session);\n    validateOptionalProfiles(session, request.getProfileActivation());\n\n    if (session.getResult().hasExceptions()) {\n      addExceptionToResult(result, session.getResult().getExceptions().get(0));\n      persistResumptionData(result, session);\n      return result;\n    } else {\n      session.getAllProjects().stream()\n          .filter(MavenProject::isExecutionRoot)\n          .findFirst()\n          .ifPresent(buildResumptionDataRepository::removeResumptionData);\n    }\n  } finally {\n    try {\n      afterSessionEnd(session);\n    } catch (MavenExecutionException e) {\n      addExceptionToResult(result, e);\n    }\n  }\n\n  return result;\n}",
			"reason": "doExecute() method performs multiple distinct responsibilities"
		},
		{
			"code": "private Set<Artifact> resolveImpl(\n  Collection<? extends MavenProject> projects,\n  Collection<String> scopesToCollect,\n  Collection<String> scopesToResolve,\n  MavenSession session,\n  Set<String> projectIds)\n  throws ArtifactResolutionException, ArtifactNotFoundException {\n\n  Set<Artifact> resolved = new LinkedHashSet<>();\n\n  if (projects == null || projects.isEmpty()) {\n    return resolved;\n  }\n\n  if ((scopesToCollect == null || scopesToCollect.isEmpty())\n      && (scopesToResolve == null || scopesToResolve.isEmpty())) {\n    return resolved;\n  }\n\n  /*\n  Logic for transitive global exclusions\n\n  List<String> exclusions = new ArrayList<String>();\n\n  for ( Dependency d : project.getDependencies() )\n  {\n    if ( d.getExclusions() != null )\n    {\n      for ( Exclusion e : d.getExclusions() )\n      {\n        exclusions.add(  e.getGroupId() + \":\" + e.getArtifactId() );\n      }\n    }\n  }\n\n  ArtifactFilter scopeFilter = new ScopeArtifactFilter( scope );\n\n  ArtifactFilter filter;\n\n  if ( ! exclusions.isEmpty() )\n  {\n    filter = new AndArtifactFilter( Arrays.asList( new ArtifactFilter[]{\n      new ExcludesArtifactFilter( exclusions ), scopeFilter } ) );\n  }\n  else\n  {\n    filter = scopeFilter;\n  }\n  */\n\n  CumulativeScopeArtifactFilter resolutionScopeFilter = new CumulativeScopeArtifactFilter(scopesToResolve);\n\n  CumulativeScopeArtifactFilter collectionScopeFilter = new CumulativeScopeArtifactFilter(scopesToCollect);\n  collectionScopeFilter = new CumulativeScopeArtifactFilter(collectionScopeFilter, resolutionScopeFilter);\n\n  ArtifactResolutionRequest request = new ArtifactResolutionRequest()\n    .setResolveRoot(false)\n    .setResolveTransitively(true)\n    .setCollectionFilter(collectionScopeFilter)\n    .setResolutionFilter(resolutionScopeFilter)\n    .setLocalRepository(session.getLocalRepository())\n    .setOffline(session.isOffline())\n    .setForceUpdate(session.getRequest().isUpdateSnapshots());\n  request.setServers(session.getRequest().getServers());\n  request.setMirrors(session.getRequest().getMirrors());\n  request.setProxies(session.getRequest().getProxies());\n\n  for (MavenProject project : projects) {\n    request.setArtifact(new ProjectArtifact(project));\n    request.setArtifactDependencies(project.getDependencyArtifacts());\n    request.setManagedVersionMap(project.getManagedVersionMap());\n    request.setRemoteRepositories(project.getRemoteArtifactRepositories());\n\n    ArtifactResolutionResult result = repositorySystem.resolve(request);\n\n    try {\n      resolutionErrorHandler.throwErrors(request, result);\n    } catch (MultipleArtifactsNotFoundException e) {\n\n      Collection<Artifact> missing = new HashSet<>(e.getMissingArtifacts());\n\n      for (Iterator<Artifact> it = missing.iterator(); it.hasNext(); ) {\n        String key = ArtifactUtils.key(it.next());\n        if (projectIds.contains(key)) {\n          it.remove();\n        }\n      }\n\n      if (!missing.isEmpty()) {\n        throw e;\n      }\n    }\n\n    resolved.addAll(result.getArtifacts());\n  }\n\n  return resolved;\n}",
			"reason": "Argument checking, filtering, resolution, and aggregation in one method"
		}
	]
  }
]